---
title: "An observation on ggplot facets with maps"
author: "H. Sherry Zhang"
date: '2022-05-21'
slug: []
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2022-05-21T22:49:21+10:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE,
                      fig.align = "center")
library(SpatialEpiApp)
library(SpatialEpi)
library(tidyverse)
library(sf)
library(patchwork)
library(ggtext)
```

Maps are everywhere and here I have an interesting observation on faceted maps for you. 

```{r}
ohio <- read_sf(system.file("SpatialEpiApp/data/Ohio/fe_2007_39_county/fe_2007_39_county.shp", 
                           package = "SpatialEpiApp")) %>% 
  select(NAME, geometry)
```

This example comes from [Chapter 7 of Paula Moraga's book Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny](https://www.paulamoraga.com/book-geospatial/sec-arealdataexamplest.html) and I have simplified it for my demonstration. In essence, there are two datasets: 

1. A map data (`ohio`) with `r nrow(ohio)` Ohio counties in an `sf` object: 

```{r}
ohio
```

2. A lung cancer data (`sir`) with standardized incidence ratios (SIRs) calculated for each county across 21 years (1968 - 1988):

```{r}
ohio_raw <- read_csv(system.file("SpatialEpiApp/data/Ohio/dataohiocomplete.csv", 
                    package = "SpatialEpiApp"))

dt <- ohio_raw %>% arrange(county, year, gender, race) 
res <- dt %>% 
  group_by(NAME, year) %>% 
  summarise(Y = sum(y)) %>% 
  ungroup()

n_strata <- 4
E <- expected(population = dt$n, cases = dt$y, n.strata = n_strata)
nyears <- length(unique(ohio_raw$year))
countiesE <- rep(unique(ohio_raw$NAME), each = nyears)

ncounties <- length(unique(ohio_raw$NAME))
yearsE <- rep(unique(ohio_raw$year), time = ncounties)

sir <- tibble(county = countiesE, year = yearsE, E = E) %>% 
  left_join(res, by = c("county" = "NAME", "year")) %>% 
  mutate(SIR = Y/E) %>% 
  select(county, year, SIR)
```

```{r}
sir
```

The details on calculating SIR is not the focus of this post and Section [7.1](https://www.paulamoraga.com/book-geospatial/sec-arealdataexamplest.html#sec-arealdataexamplest) to [7.2](https://www.paulamoraga.com/book-geospatial/sec-arealdataexamplest.html#data-preparation-1) of Paula's book has detailed all the steps you need if interested. 

What we would like to do here is to show those SIR values of each county on the map across year. This would require us to join the two datasets, supply the combined data into ggplot, plot the underlying map, fill the county polygon with `SIR`,  make facets with `year`, and lastly add a few tweaks on theme and the scale of fill. Let's give this plot a name, say `target`: 

```{r echo = TRUE}
combined <- ohio %>% 
  left_join(sir, by = c("NAME" = "county"))

target <- combined %>% 
  ggplot() + 
  geom_sf(aes(fill = SIR)) +
  facet_wrap(~year, dir = "h", ncol = 7) +
  ggtitle("SIR") + 
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_fill_gradient2(
    midpoint = 1, low = "blue", mid = "white", high = "red"
  )

target
```

Easy peasy. 

But, have you thought about how long it would take to bring this plot to you?

```{r}
combined <- ohio %>% left_join(sir, by = c("NAME" = "county")) 

make_plot <- function(data){
  data %>% 
    ggplot() + 
    geom_sf(aes(fill = SIR)) + 
    theme_bw() +
    facet_wrap(~year, dir = "h", ncol = 7) +
    theme(
      axis.text.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks = element_blank(),
    )  + 
    scale_fill_gradient2(
      limits = c(0, range(combined$SIR)[2]),
      midpoint = 1, low = "blue", mid = "white", high = "red", 
    )
}

bench_plot <- function(data){
  p <- make_plot(data)
  benchplot(p)
}

get_total <- function(df) as.numeric(df$elapsed[5])
get_draw <- function(df) as.numeric(df$elapsed[4])
```

```{r}
p1 <- ohio %>% 
  ggplot() + 
  geom_sf() +  
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
  )

dt2 <- combined %>% filter(year == 1968)
dt3 <- combined %>% filter(year %in% c(1968, 1969))
dt4 <- combined
```

```{r eval = FALSE}
dev.new()
t1 <- benchplot(p1)
while (dev.cur()>1) dev.off()
t234 <- map(list(dt2 = dt2, dt3 = dt3, dt4 = dt4), ~{
  dev.new()
  out <- .x %>% bench_plot()
  while (dev.cur()>1) dev.off()
  return(out)
})

time <- c(list(dt1 = t1), t234)

save(time, file = here::here("content/post/2022-05-21-ggplot-sf/time.rda"))
```

```{r}
load("time.rda")
```

Let me show you some components of this plot as benchmarks, here I have: 

  1) `P0`: a single map object (left): **`r get_total(time$dt1)` secs**
  
  2) `P1`: a single year (1968) with SIR filled (mid): **`r get_total(time$dt2)` secs**, and
  
  3) `P2`: two years (1968 & 1969) with SIR filled in facets (right): **`r get_total(time$dt3)` secs**

```{r fig.width=10, fig.height=3.5}
p5 <- p1 + 
  labs(title = "P0: a single map object",
       subtitle = glue::glue("{round(get_total(time$dt1), 5)} secs"))

p6 <- dt2 %>% 
  make_plot() +
  labs(title = "P1: a single year (1968)",
       subtitle = glue::glue("{round(get_total(time$dt2),5)} secs"))

p7 <- dt3 %>% 
  make_plot() + 
  labs(title = "P2: two years (1968 & 1969) with SIR filled in facets",
       subtitle = glue::glue("{round(get_total(time$dt3),5)} secs")) 

(p5 | p6 | p7) + 
  plot_layout(guides = 'collect', widths = c(1, 1, 2)) &
  theme(legend.position='right')  
```

okay, now it is your time to make a guess: 

 - ~1 or 2 seconds? Ideally if the same map is rendered in parallel across all the facets, the increment of time would be marginal. 
 
 - ~`r round(get_total(time$dt2) + (get_total(time$dt3) - get_total(time$dt2)) * 21)` seconds? The increment of rendering another facet from 2) to 3) is `r round(get_total(time$dt3),5) - round(get_total(time$dt2),5)` (`r round(get_total(time$dt3),5)`-`r round(get_total(time$dt2),5)`) seconds.  Projecting that into 20 more facets will give us: `r round(get_total(time$dt2),5)` + (`r round(get_total(time$dt3),5)`-`r round(get_total(time$dt2),5)`) * 20 = `r round(get_total(time$dt2) + (get_total(time$dt3) - get_total(time$dt2)) * 21,5)` seconds. 
 
 - 30 seconds, 40 seconds, 1 minute? I don't know. I just run your code and have waited a while for this plot to appear. 
 
### Let's reveal the answer

There are different ways to check the execution time of a command and here we use `ggplot2::benchplot()` which can break down the time by building, rendering, and drawing: 

```{r}
ggplot2::benchplot
```

Ready for the answer? Here you go: 

```{r echo = TRUE, eval = FALSE}
benchplot(target)
```

```{r}
time$dt4
```

WOW, I do not expect it to take `r round(get_total(time$dt4), 5)` seconds to get our plot! 

### How come it take that long? 

We can take a look at the time decomposition of our target plot along with the three benchmark plots. This would tell us at which stage our target plot takes long: 

```{r fig.width=10, fig.height=3.5}
dt <- do.call(bind_rows, time) %>% 
  as_tibble() %>% 
  mutate(plot = factor(rep(paste0("p", c(0:2, 21)), each = 5)),
         step = factor(step, levels = c("construct", "build","render", "draw", "TOTAL"))) %>% 
  filter(step != "construct") 

dt %>% 
  ggplot(aes(x = plot, y = sqrt(elapsed), color = plot, fill = plot)) + 
  geom_col() + 
  geom_text(aes(y = sqrt(elapsed) - 0.1, label = round(elapsed, 2)), color = "black")+ 
  facet_wrap(vars(step), nrow = 1)  + 
  scale_y_continuous(breaks = seq(0, 6, 1)) + 
  labs(y = "<b>square root</b> of elapsed time") +
  theme(axis.title.y = element_markdown())
```

Here `p0` to `p2` are the three benchmark plots and `p21` is the target plot (since it has 21 facets). Notice the y-axis is the **square root** of elapsed time and the text on each bar is the **actual** elapsed time. 

Building and rendering time look fine and our target plot is taking a considerable large amount of time in the drawing. Looking back into `benchplot()`, this happens when drawing the grob with `grid.draw()`: 

```{r eval = FALSE, echo = TRUE}
draw <- system.time(grid.draw(grob))
```

We could also do an experiment to progressively add one facets to see how the drawing time changes as there are more facets. Here I start with `p1` containing only year 1968 and `p2` containing year 1968 & 1969, and add one more year at a time till `p21` which contains all the 21 years from 1968 to 1988. 

<!-- The function `benchplot()` only evaluates the plot once and to get an average result of the performance, we need to repeat the evaluation. Here we need to be a little bit cautious.  -->

<!--   - The plot device needs to be cleared every time before the evaluation. The time it takes to draw on an existing plot is different from drawing on a fresh canvas and it is significantly different from drawing on 20 existing plots.  -->

Here is the script I used to make the simulation: 

```{r eval = FALSE, echo = TRUE}
combined <- ohio %>% left_join(sir, by = c("NAME" = "county")) 

make_plot <- function(data){
  data %>% 
    ggplot() + 
    geom_sf(aes(fill = SIR)) + 
    theme_bw() +
    facet_wrap(~year, dir = "h", ncol = 7) +
    theme(
      axis.text.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks = element_blank(),
    )  + 
    scale_fill_gradient2(
      limits = c(0, range(combined$SIR)[2]),
      midpoint = 1, low = "blue", mid = "white", high = "red", 
    )
}

bench_plot <- function(data){
  p <- make_plot(data)
  benchplot(p)
}

time_all <- map_dfr(year, function(y){
    dt <- combined %>% filter(year <= y)
    dev.new()
    out <- dt %>% bench_plot()
    while (dev.cur()>1) dev.off()
    return(out)
}, .id = "plot")
```

Note that the workhorse (`out <- dt %>% bench_plot()`) here is wrapped in between `dev.new()` and 
`while (dev.cur()>1) dev.off()`, so a clean canvas is set up before each evaluation. Now we can plot the result and take a look: 

```{r}
load("time_all.rda")

dat <- do.call(bind_rows, time_all) %>% 
  as_tibble() %>% 
  filter(step == "draw") %>%
  mutate(plot = 1:21)

two <- dat %>% filter(plot <= 2)
slope <- diff(two$elapsed)
dat %>% 
  ggplot(aes(x = plot, y = elapsed)) +
  geom_point() + 
  geom_vline(xintercept = 7, linetype = "dotted", color = "#006DAE") + 
  geom_vline(xintercept = 14, linetype = "dotted", color = "#006DAE") + 
  geom_vline(xintercept = 21, linetype = "dotted", color = "#006DAE") + 
  geom_abline(slope = slope, intercept = two$elapsed[1] - slope, 
              linetype = "longdash", color = "#006DAE") + 
  scale_y_continuous(breaks = seq(0, 30, 2)) + 
  scale_x_continuous(breaks = seq(1, 21, 1), labels = paste0("p", rep(1:21))) + 
  labs(y = "elapsed time (drawing)") 
```   

The three dotted vertical lines are where the a new row takes place in the facet. The dashed line connects `p1` and `p2` and shows how the elapsed time would be if a linear pattern is followed. Unfortunately, we don't have a linear relationship. 

Looking at these points, something wired is going on here: by the end of the first row, the increment from having six facets (`p6`) to seven facets (`p7`) is much larger than those in early plots (`p1` to `p5`). However, the end of the second row tells us something else: the increment from having 13 facets (`p13`) to 14 facets (`p14`) is almost negligible. This is also the case at the end of the third row (`p20` and `p21`).


```{r results='hide'}
ohio2 <- ohio %>% rmapshaper::ms_simplify()

combined2 <- ohio2 %>% left_join(sir, by = c("NAME" = "county"))

target2 <- combined2 %>% 
  ggplot() + 
  geom_sf(aes(fill = SIR)) +
  facet_wrap(~year, dir = "h", ncol = 7) +
  ggtitle("SIR") + 
  theme_bw() +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_fill_gradient2(
    midpoint = 1, low = "blue", mid = "white", high = "red"
  )

dev.new()
res <- benchplot(target2)    
while (dev.cur()>1) dev.off()
```

While I can't find the answer of why the drawing time with additional facets has such a pattern, what initially annoys me was it takes much longer than I expected to create the target plot. If we only want to cut the run time, there is always the trick of simplifying your map object. Applying `rmapshaper:: ms_simplify()` on `ohio` will keep 1% of the points in the polygons by default and it can instantly brings the rendering time of our target plot down to `r get_total(res)` seconds: 

```{r eval = FALSE, echo = TRUE}
ohio2 <- ohio %>% rmapshaper::ms_simplify()
combined2 <- ohio2 %>% left_join(sir, by = c("NAME" = "county"))
target2 <- combined2 %>% make_plot()
benchplot(target2)
```

```{r}
res
```

And how the plot looks like after the simplification? 

```{r}
target2
```

At least I can't tell it from the origin plot. 

Technically, we didn't answer the question why it takes that long to render our target plot or how `grid.draw()` plots the facets. In an ideal world, there is some intelligence to 


